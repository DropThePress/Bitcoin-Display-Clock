<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Price Display</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #666;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        .price-container {
            text-align: center;
            width: 100vw; /* Full width, no padding */
            max-width: 100vw;
            height: 80vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .btc-label {
            font-size: 4vh;
            color: #666;
            margin-bottom: 2vh;
        }
        .price-wrapper {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Allow more vertical space for the price */
            flex-grow: 1;
            margin-bottom: 2vh;
        }
        .price {
            display: inline-block;
            font-weight: bold;
            white-space: nowrap;
            text-align: center;
            line-height: 1; /* Tighter line height for better fit */
        }
        .price-number {
            color: #f7931a;
        }
        .price-comma {
            color: #f7931a;
            font-weight: normal;
            vertical-align: baseline;
            opacity: 0.8;
            font-size: 80%; /* Relative to the auto-scaled price */
        }
        .info-container {
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
        }
        .api-name {
            font-size: 3.2vh;
            color: #666;
            margin-bottom: 0.5vh;
        }
        .timestamp {
            font-size: 2vh;
            color: #666;
        }
        .note {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 1.5vh;
            color: #444;
        }
        .update-info {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 1.5vh;
            color: #444;
        }
        .status-message {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 1.5vh;
            color: #444;
            display: none;
        }
    </style>
</head>
<body>
    <div class="price-container">
        <div class="btc-label">BTC</div>
        <div class="price-wrapper">
            <div class="price" id="btcPrice">---</div>
        </div>
    </div>
    <div class="info-container">
        <div class="api-name" id="apiName"></div>
        <div class="timestamp" id="lastUpdated">Updating...</div>
    </div>
    <div class="note">Click anywhere for fullscreen</div>
    <div class="update-info" id="updateInfo"></div>
    <div class="status-message" id="statusInfo"></div>

    <script>
        // API Configuration - Multiple sources for redundancy, ordered by update frequency
        const APIs = [
            {
                name: "Binance",
                type: "fetch",
                url: "https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT",
                updateFrequency: 1000, // 1 second in milliseconds
                displayFrequency: "1 sec",
                processData: function(data) {
                    return parseFloat(data?.price);
                }
            },
                        {
                name: "Binance US",
                type: "fetch",
                url: "https://api.binance.us/api/v3/ticker/price?symbol=BTCUSDT",
                updateFrequency: 1000, // 1 second in milliseconds
                displayFrequency: "1 sec",
                processData: function(data) {
                    return parseFloat(data?.price);
                }
            },
            {
                name: "Coinbase",
                type: "fetch",
                url: "https://api.coinbase.com/v2/prices/BTC-USD/spot",
                updateFrequency: 5000, // 5 seconds
                displayFrequency: "5 sec",
                processData: function(data) {
                    return parseFloat(data?.data?.amount);
                }
            },
            {
                name: "Bitstamp",
                type: "fetch",
                url: "https://www.bitstamp.net/api/v2/ticker/btcusd/",
                updateFrequency: 5000, // 5 seconds
                displayFrequency: "5 sec",
                processData: function(data) {
                    return parseFloat(data?.last);
                }
            },
            {
                name: "Gemini",
                type: "fetch",
                url: "https://api.gemini.com/v1/pubticker/btcusd",
                updateFrequency: 7000, // 7 seconds
                displayFrequency: "7 sec",
                processData: function(data) {
                    return parseFloat(data?.last);
                }
            },
            {
                name: "Bittrex",
                type: "fetch",
                url: "https://api.bittrex.com/v3/markets/BTC-USD/ticker",
                updateFrequency: 12000, // 12 seconds
                displayFrequency: "12 sec",
                processData: function(data) {
                    return parseFloat(data?.lastTradeRate);
                }
            },
            {
                name: "Bitfinex",
                type: "fetch",
                url: "https://api-pub.bitfinex.com/v2/ticker/tBTCUSD",
                updateFrequency: 12000, // 12 seconds
                displayFrequency: "12 sec",
                processData: function(data) {
                    return data?.[6]; // Last price
                }
            },
            {
                name: "Kraken",
                type: "fetch",
                url: "https://api.kraken.com/0/public/Ticker?pair=XBTUSD",
                updateFrequency: 15000, // 15 seconds
                displayFrequency: "15 sec",
                processData: function(data) {
                    return parseFloat(data?.result?.XXBTZUSD?.c[0]);
                }
            },
            {
                name: "Blockchain.info",
                type: "fetch",
                url: "https://blockchain.info/ticker",
                updateFrequency: 15000, // 15 seconds
                displayFrequency: "15 sec",
                processData: function(data) {
                    return data?.USD?.last;
                }
            },
            {
                name: "CoinGecko",
                type: "fetch", 
                url: "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd",
                updateFrequency: 45000, // 45 seconds
                displayFrequency: "45 sec",
                processData: function(data) {
                    return data?.bitcoin?.usd;
                }
            },
            {
                name: "Coindesk",
                type: "jsonp",
                url: "https://api.coindesk.com/v1/bpi/currentprice.json",
                updateFrequency: 60000, // 60 seconds
                displayFrequency: "60 sec",
                processData: function(data) {
                    return data?.bpi?.USD?.rate_float;
                }
            }
        ];
        
        let currentApiIndex = 0;
        let currentUpdateInterval = null;
        let lastSuccessfulPrice = null;
        let lastSuccessfulApiTime = 0;
        let rateLimitedApis = new Set();
        let lastUpdateTime = 0;
        let updateTimer = null;
        let primaryApiCheckTimer = null;
        
        // Function to resize the price to fill the screen width
        function resizePriceToFit() {
            const priceElement = document.getElementById('btcPrice');
            const priceWrapper = document.querySelector('.price-wrapper');
            
            // Get container dimensions
            const containerWidth = priceWrapper.offsetWidth;
            const containerHeight = priceWrapper.offsetHeight;
            
            // Reset font size first to measure initial size
            priceElement.style.fontSize = '100px';
            
            // Calculate width/height ratio (we want to fill as much as possible)
            let maxSize = Math.min(containerWidth, containerHeight * 1.5);
            
            // Start with a reasonable font size (scaled to container)
            let fontSize = 100;
            let step = 25;
            
            // Binary search approach for faster sizing
            priceElement.style.fontSize = fontSize + 'px';
            
            // First rapidly increase size until too big
            while (priceElement.offsetWidth < containerWidth && fontSize < 1000) {
                fontSize += step;
                priceElement.style.fontSize = fontSize + 'px';
            }
            
            // Then back off a bit
            fontSize -= step;
            priceElement.style.fontSize = fontSize + 'px';
            
            // Then fine tune with smaller steps
            step = 5;
            while (priceElement.offsetWidth < containerWidth && fontSize < 1000) {
                fontSize += step;
                priceElement.style.fontSize = fontSize + 'px';
            }
            
            // Final adjustment to ensure it fits
            while (priceElement.offsetWidth > containerWidth && fontSize > 10) {
                fontSize -= 1;
                priceElement.style.fontSize = fontSize + 'px';
            }
            
            // Apply 95% of the final size to ensure it really fits
            priceElement.style.fontSize = (fontSize * 0.95) + 'px';
            
            console.log(`Adjusted price font size to ${fontSize * 0.95}px`);
        }
        
        // Function to format price with commas, but no cents
        function formatPrice(price) {
            // Round to nearest integer
            const roundedPrice = Math.round(price);
            
            // Format with commas
            const priceString = roundedPrice.toString();
            let formattedPrice = '';
            
            // Add commas manually with spans to color them differently
            for (let i = 0; i < priceString.length; i++) {
                formattedPrice += `<span class="price-number">${priceString[i]}</span>`;
                
                // Add comma after every 3 digits from the right
                if ((priceString.length - i - 1) % 3 === 0 && i !== priceString.length - 1) {
                    formattedPrice += `<span class="price-comma">,</span>`;
                }
            }
            
            return formattedPrice;
        }
        
        // Function to fetch BTC price using fetch API
        async function fetchPriceWithFetch(api) {
            try {
                if (rateLimitedApis.has(api.name)) {
                    return null; // Skip rate-limited APIs
                }
                
                const cacheBuster = `_cb=${Date.now()}`;
                const url = api.url + (api.url.includes('?') ? '&' : '?') + cacheBuster;
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout
                
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    // Check for rate limit responses
                    if (response.status === 429 || response.status === 403) {
                        rateLimitedApis.add(api.name);
                        setTimeout(() => rateLimitedApis.delete(api.name), 60000); // Try again after a minute
                        showStatus(`Rate limited: ${api.name}`);
                    }
                    throw new Error(`Error: Status ${response.status}`);
                }
                
                const data = await response.json();
                const price = api.processData(data);
                
                if (price && !isNaN(price) && price > 0) {
                    return price;
                } else {
                    throw new Error("Invalid price data");
                }
            } catch (error) {
                console.log(`${api.name} API error:`, error);
                return null;
            }
        }
        
        // Function to fetch BTC price using JSONP
        function fetchPriceWithJsonp(api) {
            return new Promise((resolve) => {
                if (rateLimitedApis.has(api.name)) {
                    resolve(null); // Skip rate-limited APIs
                    return;
                }
                
                const callbackName = 'btcCallback_' + Date.now();
                const script = document.createElement('script');
                
                // Set timeout to handle failed requests
                const timeoutId = setTimeout(() => {
                    cleanup();
                    resolve(null);
                }, 3000); // 3 second timeout
                
                // Cleanup function
                function cleanup() {
                    clearTimeout(timeoutId);
                    if (script.parentNode) {
                        document.body.removeChild(script);
                    }
                    delete window[callbackName];
                }
                
                // Setup callback
                window[callbackName] = function(data) {
                    cleanup();
                    try {
                        const price = api.processData(data);
                        if (price && !isNaN(price) && price > 0) {
                            resolve(price);
                        } else {
                            resolve(null);
                        }
                    } catch (error) {
                        console.log(`${api.name} API error:`, error);
                        resolve(null);
                    }
                };
                
                // Handle script errors
                script.onerror = function() {
                    cleanup();
                    resolve(null);
                };
                
                // Set source and append to document
                script.src = `${api.url}${api.url.includes('?') ? '&' : '?'}callback=${callbackName}&_=${Date.now()}`;
                document.body.appendChild(script);
            });
        }
        
        // Function to show status message
        function showStatus(message, duration = 5000) {
            const statusElement = document.getElementById('statusInfo');
            statusElement.textContent = message;
            statusElement.style.display = 'block';
            
            // Hide after duration
            setTimeout(() => {
                statusElement.style.display = 'none';
            }, duration);
        }
        
        // Function to update the display elements for the current API
        function updateApiInfo(api) {
            const updateInfoElement = document.getElementById('updateInfo');
            const apiNameElement = document.getElementById('apiName');
            
            updateInfoElement.textContent = `Update frequency: ${api.displayFrequency}`;
            apiNameElement.textContent = api.name;
        }
        
        // Function to adjust the update interval based on the current API
        function setUpdateInterval(api) {
            if (updateTimer) {
                clearInterval(updateTimer);
            }
            
            updateTimer = setInterval(fetchBitcoinPrice, api.updateFrequency);
            console.log(`Set update interval to ${api.updateFrequency}ms for ${api.name}`);
        }
        
        // Function to check if a more preferred API is available
        async function checkForPreferredApi() {
            // Only run this check if we're not on the first (most preferred) API
            if (currentApiIndex === 0) {
                return;
            }
            
            // Try each API with higher preference than the current one
            for (let i = 0; i < currentApiIndex; i++) {
                const api = APIs[i];
                
                // Skip if rate limited
                if (rateLimitedApis.has(api.name)) {
                    continue;
                }
                
                updateApiInfo(api);
                
                // Use appropriate fetch method based on API type
                let price = null;
                if (api.type === "jsonp") {
                    price = await fetchPriceWithJsonp(api);
                } else {
                    price = await fetchPriceWithFetch(api);
                }
                
                // If we got a valid price, switch to this API
                if (price !== null) {
                    // Update the price display
                    updatePriceDisplay(price, api);
                    currentApiIndex = i;
                    setUpdateInterval(api);
                    showStatus(`Switched to faster API: ${api.name}`);
                    return;
                }
            }
        }
        
        // Function to update the price display
        function updatePriceDisplay(price, api) {
            const priceElement = document.getElementById('btcPrice');
            const timestampElement = document.getElementById('lastUpdated');
            
            // Format price as integer with commas
            const formattedPrice = formatPrice(price);
            
            // Update the price display with HTML
            priceElement.innerHTML = formattedPrice;
            lastSuccessfulPrice = price;
            lastSuccessfulApiTime = Date.now();
            
            // Resize to fit screen
            resizePriceToFit();
            
            // Update timestamp
            const nowTime = new Date();
            timestampElement.textContent = `Last updated: ${nowTime.toLocaleTimeString()}`;
            
            // Update API info
            updateApiInfo(api);
        }
        
        // Main function to try all APIs in sequence
        async function fetchBitcoinPrice() {
            const now = Date.now();
            
            // Try each API in sequence
            for (let i = 0; i < APIs.length; i++) {
                // Start with current index and wrap around
                const apiIndex = (currentApiIndex + i) % APIs.length;
                const api = APIs[apiIndex];
                
                // Use appropriate fetch method based on API type
                let price = null;
                if (api.type === "jsonp") {
                    price = await fetchPriceWithJsonp(api);
                } else {
                    price = await fetchPriceWithFetch(api);
                }
                
                // If we got a valid price, update display
                if (price !== null) {
                    // If we're using a different API than before, update the interval
                    if (apiIndex !== currentApiIndex) {
                        currentApiIndex = apiIndex;
                        setUpdateInterval(api);
                        console.log(`Switched to API: ${api.name}`);
                    }
                    
                    // Update the display
                    updatePriceDisplay(price, api);
                    return;
                }
            }
            
            // If all APIs failed but we have a previous price, keep showing it
            if (lastSuccessfulPrice) {
                // Update timestamp to show error
                const nowTime = new Date();
                document.getElementById('lastUpdated').textContent = 
                    `All APIs failed. Last price from: ${nowTime.toLocaleTimeString()}`;
                
                // If it's been more than a minute since our last successful update,
                // maybe we need to re-evaluate the API selection
                if (now - lastSuccessfulApiTime > 60000) {
                    // Reset to first API and try again
                    currentApiIndex = 0;
                    setUpdateInterval(APIs[0]);
                    showStatus("Connection issues - resetting API selection");
                }
            } else {
                document.getElementById('btcPrice').innerHTML = `<span class="price-number">---</span>`;
                document.getElementById('lastUpdated').textContent = "Could not connect to any API";
                resizePriceToFit();
            }
        }

        // Initialize the display
        function initializeDisplay() {
            // Set up the initial API
            currentApiIndex = 0;
            const initialApi = APIs[currentApiIndex];
            updateApiInfo(initialApi);
            
            // Fetch price initially
            fetchBitcoinPrice();
            
            // Set initial update interval
            setUpdateInterval(initialApi);
            
            // Check for more preferred APIs every 5 minutes
            primaryApiCheckTimer = setInterval(checkForPreferredApi, 300000); // 5 minutes in milliseconds
            
            // Set up resize listener
            window.addEventListener('resize', function() {
                // Delay resize slightly to ensure DOM is updated
                setTimeout(resizePriceToFit, 100);
            });
        }

        // Start the display when the page loads
        window.addEventListener('load', initializeDisplay);
        
        // Toggle fullscreen when tapping the screen
        document.addEventListener('click', () => {
            try {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log(`Error attempting to enable fullscreen: ${err.message}`);
                    });
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            } catch (error) {
                console.log('Fullscreen toggle error:', error.message);
            }
        });
    </script>
</body>
</html>
