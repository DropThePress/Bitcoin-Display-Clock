<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Price Display</title>
    <!-- Preconnect links are okay - they don't download fonts, just speed up later connections -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- REMOVED Google Font stylesheet links -->
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif; /* Default font, overridden by settings */
            background-color: #000; /* Default, overridden */
            /* color: set by JS 'otherTextColor' */
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Prevent scrollbars */
        }
        .price-container {
            text-align: center;
            width: 100vw;
            max-width: 100vw;
            height: 80vh; /* Main area for the price */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; /* Center price vertically and horizontally */
        }
        .btc-label {
            font-size: 4vh; /* Base size, scaled by JS */
            /* color: set by JS 'otherTextColor' */
            margin-bottom: 2vh;
            display: block; /* Default, controlled by JS toggle */
        }
        .price-wrapper {
            width: 100%;
            height: 100%; /* Fill the container */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            margin-bottom: 2vh; /* Space below price */
        }
        .price {
            display: inline-block;
            font-weight: bold;
            white-space: nowrap;
            text-align: center;
            line-height: 1; /* Ensure tight line spacing */
             /* Font size is set dynamically by JS resizePriceToFit */
        }
        .price-number {
            /* color: set by JS 'textColor' */
            /* Font size inherited from .price */
        }
        .price-comma {
            /* color: set by JS 'textColor' */
            font-weight: normal; /* Make comma less bold */
            vertical-align: baseline; /* Align comma properly */
            opacity: 0.8; /* Slightly fade comma */
            font-size: 80%; /* Make comma slightly smaller relative to numbers */
        }
        .info-container {
            position: fixed;
            bottom: 60px; /* Adjusted position slightly higher to not overlap bottom buttons */
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none; /* Allow clicks through info */
            z-index: 1; /* Ensure it's above background but below buttons/modal */
        }
        .api-name, .timestamp {
            font-size: 4vh; /* Base size, scaled by JS */
            /* color: set by JS 'otherTextColor' */
            margin-bottom: 0.5vh;
            display: block; /* Default, controlled by JS toggle */
        }
        /* REMOVED .note and .update-info styles */

        .status-message {
             position: absolute;
             top: 5px;
             right: 5px;
             font-size: 4vh; /* Base size, scaled by JS */
             /* color: set by JS 'otherTextColor' */
             display: none; /* Hidden by default, shown by JS */
             background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent background for readability */
             padding: 2px 8px;
             border-radius: 4px;
             z-index: 50; /* Above content, below settings */
             pointer-events: none;
        }
        .settings-button {
            position: fixed;
            bottom: 20px;
            /* MOVED to left */
            left: 5px;
            background-color: rgba(100,100,100,0.5);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px; /* Fixed font size for button */
            z-index: 100;
            pointer-events: auto; /* Ensure button is clickable */
        }
        /* NEW: Fullscreen Button Styles */
        .fullscreen-button {
            position: fixed;
            bottom: 20px;
            /* Positioned right */
            right: 5px;
            background-color: rgba(100,100,100,0.5);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px; /* Fixed font size for button */
            z-index: 100;
            pointer-events: auto; /* Ensure button is clickable */
        }

        /* NEW: Hide buttons when in fullscreen using pseudo-class */
        :fullscreen .settings-button,
        :fullscreen .fullscreen-button {
            display: none;
        }
        /* NEW: Alternative using class (added by JS for potentially better cross-browser/state handling) */
        body.in-fullscreen .settings-button,
        body.in-fullscreen .fullscreen-button {
            display: none;
        }


        .settings-modal {
            position: fixed;
            bottom: 80px; /* Position above button(s) */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(50,50,50,0.9);
            color: white; /* Explicit color for modal text */
            border-radius: 10px;
            padding: 20px;
            width: 300px;
            max-width: 90vw;
            z-index: 200; /* Above everything else */
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: none; /* Hidden by default */
            pointer-events: auto; /* Ensure modal is interactive */
        }
        .settings-modal.visible {
            display: block;
        }
        .settings-option {
            margin-bottom: 15px;
        }
        .settings-option h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px; /* Fixed font size */
            font-weight: normal;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
        .color-options {
            display: flex;
            gap: 10px;
            margin-bottom: 10px; /* Space below color pickers */
            flex-wrap: wrap; /* Allow wrapping */
        }
        .color-picker {
            width: 30px; /* Slightly smaller */
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 0 3px rgba(0,0,0,0.3);
        }
        .color-picker.selected {
            border-color: #f7931a; /* Highlight selected color */
            transform: scale(1.1);
        }
         /* --- UPDATED FONT GRID --- */
        .font-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 columns */
            gap: 5px;
            margin: 5px 0;
        }
        .font-preview {
            padding: 5px;
            border: 1px solid #666;
            cursor: pointer;
            text-align: center;
            font-size: 12px; /* Smaller font size for preview */
            border-radius: 3px;
            background-color: rgba(255, 255, 255, 0.1);
            overflow: hidden; /* Prevent long names breaking layout */
            white-space: nowrap;
            text-overflow: ellipsis;
            /* Use a safe font for the preview text itself */
            font-family: Verdana, Geneva, sans-serif;
            position: relative; /* For loading indicator */
        }
        .font-preview.selected {
            background-color: rgba(255,255,255,0.2);
            border-color: #f7931a; /* Highlight selected font */
            font-weight: bold;
        }
        .font-preview .loading-indicator {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
        }
        /* Style for buttons inside modal */
        .settings-modal button {
            padding: 8px 12px;
            background-color: rgba(100,100,100,0.5);
            color: white;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px; /* Consistent button font size */
        }
        .settings-modal button:hover {
             background-color: rgba(120,120,120,0.6);
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex-grow: 1; /* Allow slider to take available space */
            cursor: pointer;
            height: 5px;
            background: #555;
            border-radius: 5px;
            appearance: none; /* Override default look */
        }
        input[type="range"]::-webkit-slider-thumb { /* Chrome/Safari */
            appearance: none;
            width: 15px;
            height: 15px;
            background: #ccc;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb { /* Firefox */
            width: 15px;
            height: 15px;
            background: #ccc;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        .slider-container span {
            min-width: 40px; /* Ensure space for percentage value */
            text-align: right;
            font-size: 14px;
        }
        .toggle-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .toggle-option {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toggle-option label {
            font-size: 14px;
            cursor: pointer;
            flex-grow: 1;
        }
         .toggle-option input[type="checkbox"] {
             cursor: pointer;
         }
        /* Hide the actual color input, trigger via button */
        input[type="color"] {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
            pointer-events: none;
        }

    </style>
</head>
<body>
    <div class="price-container">
        <div class="btc-label" id="btcLabel">BTC</div>
        <div class="price-wrapper">
            <div class="price" id="btcPrice">---</div>
        </div>
    </div>

    <div class="info-container">
        <div class="api-name" id="apiName"></div>
        <div class="timestamp" id="lastUpdated">Updating...</div>
    </div>

    <!-- REMOVED instructions div -->
    <!-- REMOVED updateInfo div -->
    <div class="status-message" id="statusInfo"></div>

    <button id="settingsButton" class="settings-button">⚙️ Settings</button>
    <!-- NEW Fullscreen Button -->
    <button id="fullscreenButton" class="fullscreen-button">Fullscreen</button>


    <div id="settingsModal" class="settings-modal">
        <div class="settings-option">
            <h3>Price Color</h3>
            <div class="color-options" id="textColorOptions">
                <div class="color-picker" title="Bitcoin Orange" data-color="#f7931a" style="background-color: #f7931a;"></div>
                <div class="color-picker" title="White" data-color="#ffffff" style="background-color: #ffffff;"></div>
                <div class="color-picker" title="Green" data-color="#46FE43" style="background-color: #46FE43;"></div>
                <input type="color" id="customTextColor" value="#f7931a">
                <button id="customTextColorBtn" title="Select custom color">Custom</button>
            </div>
        </div>
        <div class="settings-option">
            <h3>Background Color</h3>
            <div class="color-options" id="bgColorOptions">
                <div class="color-picker" title="Black" data-color="#000000" style="background-color: #000000;"></div>
                <div class="color-picker" title="White" data-color="#ffffff" style="background-color: #ffffff;"></div>
                <div class="color-picker" title="Dark Gray" data-color="#303030" style="background-color: #303030;"></div>
                <input type="color" id="customBgColor" value="#000000">
                <button id="customBgColorBtn" title="Select custom color">Custom</button>
            </div>
        </div>

        <div class="settings-option">
            <h3>Other Text Color</h3>
            <div class="color-options" id="otherTextColorOptions">
                <div class="color-picker" title="Medium Gray" data-color="#666666" style="background-color: #666666;"></div>
                <div class="color-picker" title="White" data-color="#ffffff" style="background-color: #ffffff;"></div>
                <div class="color-picker" title="Light Gray" data-color="#aaaaaa" style="background-color: #aaaaaa;"></div>
                <input type="color" id="customOtherTextColor" value="#666666">
                <button id="customOtherTextColorBtn" title="Select custom color">Custom</button>
            </div>
        </div>

        <div class="settings-option">
            <h3>Price Font Size (Scale)</h3>
            <div class="slider-container">
                <input type="range" id="priceFontSize" min="10" max="100" value="100" title="Adjust relative size">
                <span id="priceFontSizeValue">100%</span>
            </div>
        </div>
        <div class="settings-option">
            <h3>Other Font Size (Scale)</h3>
            <div class="slider-container">
                <input type="range" id="otherFontSize" min="20" max="80" value="50" title="Adjust relative size"> <!-- Adjusted range, 50% = 4vh -->
                <span id="otherFontSizeValue">50%</span>
            </div>
        </div>
        <div class="settings-option">
            <h3>Font Selection</h3>
             <!-- This div will be populated by JavaScript -->
            <div id="fontOptions" class="font-grid">
                 <!-- Font previews go here -->
            </div>
        </div>
        <div class="settings-option">
            <h3>Display Options</h3>
            <div class="toggle-container">
                <!-- REMOVED Show Instructions Toggle -->
                <div class="toggle-option">
                    <input type="checkbox" id="showUpdateTime" checked>
                    <label for="showUpdateTime">Show Update Time</label>
                </div>
                <!-- REMOVED Show Update Frequency Toggle -->
                <div class="toggle-option">
                    <input type="checkbox" id="showApiName" checked>
                    <label for="showApiName">Show API Name</label>
                </div>
                <div class="toggle-option">
                    <input type="checkbox" id="showBtcLabel" checked>
                    <label for="showBtcLabel">Show BTC Label</label>
                </div>
            </div>
        </div>
    </div>

    <script>
    // CORE DISPLAY LOGIC (IIFE 1)
    (function() {
        // Make APIs globally accessible (or pass them around) for settings module
        window.APIs = [
            {name: "Coinbase", type: "fetch", url: "https://api.coinbase.com/v2/prices/BTC-USD/spot", updateFrequency: 5000, displayFrequency: "5 sec", processData: function(data) { return parseFloat(data?.data?.amount); }},
            {name: "Bitstamp", type: "fetch", url: "https://www.bitstamp.net/api/v2/ticker/btcusd/", updateFrequency: 5000, displayFrequency: "5 sec", processData: function(data) { return parseFloat(data?.last); }},
            {name: "Gemini", type: "fetch", url: "https://api.gemini.com/v1/pubticker/btcusd", updateFrequency: 7000, displayFrequency: "7 sec", processData: function(data) { return parseFloat(data?.last); }},
            {name: "Bittrex", type: "fetch", url: "https://api.bittrex.com/v3/markets/BTC-USD/ticker", updateFrequency: 12000, displayFrequency: "12 sec", processData: function(data) { return parseFloat(data?.lastTradeRate); }},
            {name: "Bitfinex", type: "fetch", url: "https://api-pub.bitfinex.com/v2/ticker/tBTCUSD", updateFrequency: 12000, displayFrequency: "12 sec", processData: function(data) { return Array.isArray(data) ? data[6] : undefined; }}, // Index 6 is LAST_PRICE, ensure it's an array
            {name: "Kraken", type: "fetch", url: "https://api.kraken.com/0/public/Ticker?pair=XBTUSD", updateFrequency: 15000, displayFrequency: "15 sec", processData: function(data) { return parseFloat(data?.result?.XXBTZUSD?.c?.[0]); }}, // c[0] is last trade price
            {name: "Blockchain.info", type: "fetch", url: "https://blockchain.info/ticker?cors=true", updateFrequency: 15000, displayFrequency: "15 sec", processData: function(data) { return data?.USD?.last; }}, // Added cors=true just in case
            {name: "CoinGecko", type: "fetch", url: "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd", updateFrequency: 45000, displayFrequency: "45 sec", processData: function(data) { return data?.bitcoin?.usd; }},
            {name: "Coindesk", type: "jsonp", url: "https://api.coindesk.com/v1/bpi/currentprice.json", updateFrequency: 60000, displayFrequency: "60 sec", processData: function(data) { return data?.bpi?.USD?.rate_float; }}
        ];

        // Make currentApiIndex globally accessible for settings module
        window.currentApiIndex = 0;
        let lastSuccessfulPrice = null;
        let lastSuccessfulApiTime = 0;
        let rateLimitedApis = new Set();
        let updateTimer = null;
        let primaryApiCheckTimer = null;

        // Expose settings object for core logic to use - will be populated by settings module
        window.btcDisplaySettings = {};

        function resizePriceToFit(percentage) {
            const priceElement = document.getElementById('btcPrice');
            const priceWrapper = document.querySelector('.price-wrapper');
            if (!priceElement || !priceWrapper || priceWrapper.offsetWidth === 0 || priceWrapper.offsetHeight === 0) {
                 // console.warn("Cannot resize price, wrapper has no dimensions or elements missing.");
                 return; // Exit if elements not found or wrapper has no size
            }

            const maxWidth = priceWrapper.offsetWidth * 0.98; // Use 98% of width
            const maxHeight = priceWrapper.offsetHeight * 0.98; // Use 98% of height

            priceElement.style.fontSize = '10px'; // Start small

            let fontSize = Math.min(window.innerHeight * 0.4, window.innerWidth * 0.15, 500);
            priceElement.style.fontSize = fontSize + 'px';

            let low = 10, high = fontSize * 2;
            let mid;
            for(let i = 0; i < 8; i++) {
                mid = (low + high) / 2;
                priceElement.style.fontSize = mid + 'px';
                if (priceElement.scrollWidth <= maxWidth && priceElement.scrollHeight <= maxHeight) { // Use scrollWidth/Height for better accuracy
                    low = mid;
                } else {
                    high = mid;
                }
            }
            fontSize = low;

            const finalSize = fontSize * (percentage / 100);
            priceElement.style.fontSize = finalSize + 'px';
        }

        function formatPrice(price) {
            if (price === null || typeof price === 'undefined' || isNaN(price)) return `<span class="price-number">---</span>`;
            const roundedPrice = Math.round(Number(price));
            const priceString = roundedPrice.toString();
            let formattedPrice = '';
            const textColor = window.btcDisplaySettings?.textColor || '#f7931a'; // Use current setting or default
            for (let i = 0; i < priceString.length; i++) {
                formattedPrice += `<span class="price-number" style="color: ${textColor};">${priceString[i]}</span>`;
                if ((priceString.length - 1 - i) % 3 === 0 && i !== priceString.length - 1) {
                    formattedPrice += `<span class="price-comma" style="color: ${textColor};">,</span>`;
                }
            }
            return formattedPrice;
        }

        async function fetchWithTimeout(resource, options = {}, timeout = 4000) {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            try {
                const response = await fetch(resource, {
                    ...options,
                    signal: controller.signal,
                    cache: 'no-store'
                });
                clearTimeout(id);
                return response;
            } catch (error) {
                clearTimeout(id);
                if (error.name === 'AbortError') {
                     // console.log(`Fetch aborted due to timeout: ${resource}`);
                } else {
                   console.error(`Fetch error for ${resource}:`, error.message);
                }
                throw error;
            }
        }

        async function fetchPriceWithFetch(api) {
            try {
                if (rateLimitedApis.has(api.name)) return null;
                const cacheBuster = `_cb=${Date.now()}`;
                const url = api.url.includes('?') ? `${api.url}&${cacheBuster}` : `${api.url}?${cacheBuster}`;
                const response = await fetchWithTimeout(url, {}, 4000);

                if (!response.ok) {
                     if (response.status === 429 || response.status === 403) {
                         console.warn(`Rate limited: ${api.name}. Adding to temporary block list.`);
                         rateLimitedApis.add(api.name);
                         showStatus(`Rate limited: ${api.name}`, 3000);
                         setTimeout(() => { rateLimitedApis.delete(api.name); console.log(`Unblocked API: ${api.name}`); }, 60000);
                     } else { console.log(`${api.name} API error: Status ${response.status} ${response.statusText}`); }
                     return null;
                }

                const data = await response.json();
                const price = api.processData(data);

                if (price !== undefined && price !== null && !isNaN(parseFloat(price)) && parseFloat(price) > 0) {
                    return parseFloat(price);
                }
                console.log(`${api.name} API error: Invalid price data processed. Raw Data:`, data, "Processed:", price);
                return null;

            } catch (error) { if (error.name !== 'AbortError') { console.log(`${api.name} API fetch/processing error:`, error.message); } return null; }
        }

        function fetchPriceWithJsonp(api) {
            return new Promise((resolve) => {
                if (rateLimitedApis.has(api.name)) return resolve(null);
                const callbackName = 'btcCallback_' + Date.now() + Math.floor(Math.random() * 1000);
                const script = document.createElement('script');
                let timeoutId = null; let scriptAdded = false;
                function cleanup() { clearTimeout(timeoutId); if (script.parentNode && scriptAdded) { try { script.parentNode.removeChild(script); } catch (e) {} } delete window[callbackName]; }
                timeoutId = setTimeout(() => { console.log(`${api.name} JSONP timeout.`); cleanup(); resolve(null); }, 4000);
                window[callbackName] = function(data) { cleanup(); try { const price = api.processData(data); if (price !== undefined && price !== null && !isNaN(parseFloat(price)) && parseFloat(price) > 0) { resolve(parseFloat(price)); } else { console.log(`${api.name} JSONP API error: Invalid price data processed. Raw Data:`, data, "Processed:", price); resolve(null); } } catch (error) { console.log(`${api.name} JSONP processing error:`, error); resolve(null); } };
                script.onerror = function(e) { console.log(`${api.name} JSONP script error:`, e); cleanup(); resolve(null); };
                const cacheBuster = `_=${Date.now()}`; script.src = `${api.url}${api.url.includes('?') ? '&' : '?'}callback=${callbackName}&${cacheBuster}`;
                try { document.body.appendChild(script); scriptAdded = true; } catch(e) { console.error("Error appending JSONP script:", e); cleanup(); resolve(null); }
            });
        }

        let statusTimer = null;
        function showStatus(message, duration = 4000) {
            const statusElement = document.getElementById('statusInfo');
            if (!statusElement) return;
            statusElement.textContent = message; statusElement.style.display = 'block';
            if (statusTimer) clearTimeout(statusTimer);
            statusTimer = setTimeout(() => { statusElement.style.display = 'none'; statusTimer = null; }, duration);
        }
        // Make showStatus global for settings module
        window.showStatus = showStatus;

        // REMOVED updateApiInfo function

        function setUpdateInterval(api) {
            if (updateTimer) clearInterval(updateTimer);
            fetchBitcoinPrice(); // Fetch immediately
            updateTimer = setInterval(fetchBitcoinPrice, api.updateFrequency);
        }

        async function checkForPreferredApi() {
            if (window.currentApiIndex === 0 || APIs.length <= 1) return;
            for (let i = 0; i < window.currentApiIndex; i++) {
                const api = APIs[i];
                if (rateLimitedApis.has(api.name)) continue;
                let price = null;
                try { price = api.type === "jsonp" ? await fetchPriceWithJsonp(api) : await fetchPriceWithFetch(api); } catch (e) { console.error(`Error during preferred API check for ${api.name}:`, e); }
                if (price !== null) {
                    console.log(`Switching back to faster API: ${api.name}`); showStatus(`Switched to faster API: ${api.name}`, 3000);
                    window.currentApiIndex = i; updatePriceDisplay(price, api); setUpdateInterval(api); return;
                }
            }
        }

        function updatePriceDisplay(price, api) {
            const priceElement = document.getElementById('btcPrice');
            const timestampElement = document.getElementById('lastUpdated');
            const apiNameElement = document.getElementById('apiName');
            if (!priceElement) { console.error("Price element not found."); return; }
            lastSuccessfulPrice = price; lastSuccessfulApiTime = Date.now();
            priceElement.innerHTML = formatPrice(price);
            if (window.btcDisplaySettings && window.btcDisplaySettings.priceFontSize) { resizePriceToFit(window.btcDisplaySettings.priceFontSize); } else { resizePriceToFit(100); }
            const now = new Date();
            if (timestampElement) { if (window.btcDisplaySettings && window.btcDisplaySettings.showUpdateTime) { timestampElement.textContent = `Updated: ${now.toLocaleTimeString()}`; timestampElement.style.display = 'block'; } else { timestampElement.style.display = 'none'; } }
            if (apiNameElement) { if (window.btcDisplaySettings && window.btcDisplaySettings.showApiName) { apiNameElement.textContent = api.name; apiNameElement.style.display = 'block'; } else { apiNameElement.style.display = 'none'; } }
            // REMOVED call to updateApiInfo
        }

        async function fetchBitcoinPrice() {
            const now = Date.now(); let foundPrice = false; let price = null; let apiUsed = null;
            for (let i = 0; i < APIs.length; i++) {
                const apiIndex = (window.currentApiIndex + i) % APIs.length; const currentApi = APIs[apiIndex]; apiUsed = currentApi;
                price = null;
                try { if (currentApi.type === "jsonp") { price = await fetchPriceWithJsonp(currentApi); } else { price = await fetchPriceWithFetch(currentApi); } } catch (e) { console.error(`Unhandled error fetching from ${currentApi.name}:`, e); price = null; }
                if (price !== null) {
                    if (i > 0) { console.log(`Switched to fallback API: ${currentApi.name}`); showStatus(`Using fallback API: ${currentApi.name}`, 3000); window.currentApiIndex = apiIndex; clearInterval(updateTimer); updateTimer = setInterval(fetchBitcoinPrice, currentApi.updateFrequency); }
                    updatePriceDisplay(price, currentApi); foundPrice = true; break;
                }
            }
            if (!foundPrice) {
                 console.warn("All APIs failed to return a price in this cycle."); const timestampElement = document.getElementById('lastUpdated');
                 if(apiUsed){ updatePriceDisplay(null, apiUsed); } // Show '---'
                 if (timestampElement && window.btcDisplaySettings && window.btcDisplaySettings.showUpdateTime) { if (lastSuccessfulPrice !== null) { timestampElement.textContent = `Update failed. Last: ${new Date(lastSuccessfulApiTime).toLocaleTimeString()}`; } else { timestampElement.textContent = "Connecting..."; } timestampElement.style.display = 'block'; }
                 if (lastSuccessfulPrice !== null && (now - lastSuccessfulApiTime > 120000) && window.currentApiIndex !== 0) { console.log("Prolonged API failure, resetting to primary API."); showStatus("Connection issues - resetting API", 4000); window.currentApiIndex = 0; setUpdateInterval(APIs[0]); }
            }
        }

        function initializeCoreDisplay() {
             if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', runInitialization); } else { runInitialization(); }
        }

        let coreInitialized = false;
        function runInitialization() {
            if (coreInitialized) return; coreInitialized = true; window.coreInitialized = true; // Global flag
            console.log("Running Core Initialization...");
            window.currentApiIndex = 0; const initialApi = APIs[window.currentApiIndex];
            const apiNameElement = document.getElementById('apiName'); if(apiNameElement) apiNameElement.textContent = initialApi.name;
            setUpdateInterval(initialApi);
            if (primaryApiCheckTimer) clearInterval(primaryApiCheckTimer); primaryApiCheckTimer = setInterval(checkForPreferredApi, 180000);
            let resizeTimeout; window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { if (window.btcDisplaySettings && window.btcDisplaySettings.priceFontSize) { resizePriceToFit(window.btcDisplaySettings.priceFontSize); } else { resizePriceToFit(100); } }, 150); });
            window.btcPriceDisplay = { resizePriceToFit: (percentage) => resizePriceToFit(percentage) }; // Expose resize

            // REMOVED old 'click' listener for fullscreen toggle

            // --- NEW Fullscreen Logic ---
            const fullscreenButton = document.getElementById('fullscreenButton');
            if (fullscreenButton) {
                fullscreenButton.addEventListener('click', () => {
                    const isInteractive = document.activeElement.closest('.settings-button, .settings-modal, .fullscreen-button');
                    if (isInteractive) return; // Prevent triggering if clicking interactive elements

                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen().catch(err => {
                            console.warn(`Fullscreen request failed: ${err.message}. Try clicking the button again.`);
                            // Re-enable button potentially needed if browser blocks request
                            // (though usually it just fails silently or logs error)
                        });
                    }
                    // Exit is handled by the 'fullscreenchange' listener now
                });
            } else {
                console.error("Fullscreen button not found!");
            }

            function exitFullscreenHandler() {
                // Check if we are actually in fullscreen before trying to exit
                // This prevents errors if the click happens during transition
                if (document.fullscreenElement && document.exitFullscreen) {
                     document.exitFullscreen().catch(err => {
                         console.warn(`Exit fullscreen failed: ${err.message}`);
                     });
                 }
            }

            document.addEventListener('fullscreenchange', () => {
                if (document.fullscreenElement) {
                    // Entered fullscreen
                    console.log("Entered fullscreen");
                    document.body.classList.add('in-fullscreen'); // Add class for CSS styling
                    // Add a one-time click/tap listener to the whole screen to exit
                    document.documentElement.addEventListener('click', exitFullscreenHandler, { once: true, capture: true }); // Use capture to catch click before other elements potentially stop it
                } else {
                    // Exited fullscreen
                    console.log("Exited fullscreen");
                    document.body.classList.remove('in-fullscreen'); // Remove class
                    // Listener is automatically removed due to { once: true }
                    // No need to manually remove exitFullscreenHandler here
                }
            });
            // --- End NEW Fullscreen Logic ---

            console.log("Core Display Initialized."); document.dispatchEvent(new CustomEvent('coreDisplayReady'));
        }
        initializeCoreDisplay();
    })();


    // SETTINGS LOGIC (IIFE 2)
    (function() {
        console.log("Initializing Settings Logic...");

        // --- Define Available Fonts ---
        const availableFonts = [
            { name: 'Arial', family: 'Arial, sans-serif', googleSegment: null, loaded: true },
            { name: 'Anton', family: "'Anton', sans-serif", googleSegment: 'Anton', loaded: false },
            { name: 'Archivo Black', family: "'Archivo Black', sans-serif", googleSegment: 'Archivo+Black', loaded: false },
            { name: 'Arvo', family: "'Arvo', serif", googleSegment: 'Arvo:wght@400', loaded: false },
            { name: 'Chakra Petch', family: "'Chakra Petch', sans-serif", googleSegment: 'Chakra+Petch:wght@400', loaded: false },
            { name: 'DM Serif Display', family: "'DM Serif Display', serif", googleSegment: 'DM+Serif+Display:wght@400', loaded: false },
            { name: 'Londrina Shadow', family: "'Londrina Shadow', cursive", googleSegment: 'Londrina+Shadow', loaded: false },
            { name: 'Noto Serif', family: "'Noto Serif', serif", googleSegment: 'Noto+Serif:wght@400', loaded: false },
            { name: 'Press Start 2P', family: "'Press Start 2P', cursive", googleSegment: 'Press+Start+2P', loaded: false },
            { name: 'Red Hat Display', family: "'Red Hat Display', sans-serif", googleSegment: 'Red+Hat+Display:wght@400', loaded: false },
            { name: 'Roboto', family: "'Roboto', sans-serif", googleSegment: 'Roboto:wght@400', loaded: false },
            { name: 'UnifrakturMaguntia', family: "'UnifrakturMaguntia', cursive", googleSegment: 'UnifrakturMaguntia', loaded: false }
        ];
        const loadedFontLinks = new Set(); // Keep track of added <link> tags

        // Default settings - REMOVED showInstructions and showUpdateFreq
        const defaultSettings = {
            textColor: '#f7931a',
            backgroundColor: '#303030',
            otherTextColor: '#666666',
            priceFontSize: 100,
            otherFontSize: 50,
            fontFamily: availableFonts[0].family, // Default to Arial
            showUpdateTime: false,
            showApiName: true,
            showBtcLabel: false
        };

        let settings = { ...defaultSettings };
        window.btcDisplaySettings = settings; // Expose globally
        let settingsInitialized = false;

        function initializeSettings() {
            if (settingsInitialized) return;
            settingsInitialized = true;
            try {
                console.log("Loading and applying settings...");
                loadSavedSettings();
                setupSettingsUI(); // This now includes generating font previews
                applySettings();
                console.log('Settings initialized successfully');
            } catch (error) {
                console.error('Error initializing settings:', error);
                settings = { ...defaultSettings };
                window.btcDisplaySettings = settings;
                applySettings(); // Try applying defaults
            }
        }

        function saveSetting(key, value) {
            // Only save if the key exists in the default settings (prevents saving removed settings)
            if (key in defaultSettings) {
                try { localStorage.setItem(`btcDisplay_${key}`, value); } catch (e) { console.error(`Error saving setting ${key}:`, e); if (window.showStatus) { window.showStatus("Error saving settings", 3000); } }
            } else {
                console.warn(`Attempted to save unknown setting: ${key}`);
            }
        }

        function loadSavedSettings() {
            console.log("Loading saved settings...");
            Object.keys(defaultSettings).forEach(key => {
                const savedValue = localStorage.getItem(`btcDisplay_${key}`);
                if (savedValue !== null) {
                    if (typeof defaultSettings[key] === 'boolean') settings[key] = (savedValue === 'true');
                    else if (typeof defaultSettings[key] === 'number') settings[key] = isNaN(parseInt(savedValue, 10)) ? defaultSettings[key] : parseInt(savedValue, 10);
                    else settings[key] = savedValue; // Strings (colors, font family)
                }
                 if (key === 'fontFamily') {
                     const foundFont = availableFonts.find(f => f.family === settings.fontFamily);
                     // No action needed here, applySettings will handle loading if necessary
                 }
            });
             // Ensure Arial is selected if the saved font is somehow invalid/missing
             if (!availableFonts.some(f => f.family === settings.fontFamily)) {
                 settings.fontFamily = availableFonts[0].family;
                 console.warn("Saved font not found in available list, defaulting to Arial.");
             }

            window.btcDisplaySettings = settings;
        }

        function applySettings() {
             // console.log("Applying settings:", settings);
            try {
                document.body.style.backgroundColor = settings.backgroundColor;
                const otherColorTargets = [ document.body, document.querySelector('.btc-label'), document.querySelector('.api-name'), document.querySelector('.timestamp'), /* REMOVED .note */ /* REMOVED .update-info */ document.querySelector('.status-message') ];
                otherColorTargets.forEach(el => { if (el) { el.style.color = settings.otherTextColor; } });
                document.querySelectorAll('.price-number, .price-comma').forEach(el => { el.style.color = settings.textColor; });

                // --- Apply Font Family ---
                document.body.style.fontFamily = settings.fontFamily;

                if (window.btcPriceDisplay?.resizePriceToFit) { window.btcPriceDisplay.resizePriceToFit(settings.priceFontSize); } else { console.warn("resizePriceToFit not available."); }
                const baseOtherFontSizeVh = 4; const otherFontScale = (settings.otherFontSize / 50); const newOtherSizeVh = baseOtherFontSizeVh * otherFontScale;
                const otherFontTargets = [ document.querySelector('.btc-label'), document.querySelector('.api-name'), document.querySelector('.timestamp'), /* REMOVED .note */ /* REMOVED .update-info */ document.querySelector('.status-message') ];
                otherFontTargets.forEach(el => { if (el) { el.style.fontSize = `${newOtherSizeVh}vh`; } });

                // REMOVED handling for #instructions and showInstructions
                document.getElementById('lastUpdated').style.display = settings.showUpdateTime ? 'block' : 'none';
                // REMOVED handling for #updateInfo and showUpdateFreq
                document.getElementById('apiName').style.display = settings.showApiName ? 'block' : 'none';
                document.getElementById('btcLabel').style.display = settings.showBtcLabel ? 'block' : 'none';

                // Re-apply API info visibility (API Name needs text content update if shown)
                if (window.APIs && typeof window.currentApiIndex !== 'undefined') {
                    const currentApi = window.APIs[window.currentApiIndex];
                    if (currentApi) {
                        const apiNameElement = document.getElementById('apiName');
                        if (apiNameElement) {
                            if (settings.showApiName) {
                                apiNameElement.textContent = currentApi.name; // Ensure name is current
                                apiNameElement.style.display = 'block';
                            } else {
                                apiNameElement.style.display = 'none';
                            }
                        }
                        // No need to handle updateInfoElement anymore
                    }
                } else {
                     // Hide elements if core isn't ready yet
                    const apiNameElement = document.getElementById('apiName');
                    if (apiNameElement) apiNameElement.style.display = 'none';
                    // No updateInfoElement
                }


                updateSettingsUI(); // Update modal UI
            } catch (e) { console.error('Error applying settings:', e); }
        }

        function updateSettingsUI() {
            if (!settingsInitialized) return;
            try {
                 function updateColorUI(optionsId, customInputId, settingKey) {
                     const container = document.getElementById(optionsId); const customInput = document.getElementById(customInputId);
                     if (container) { container.querySelectorAll('.color-picker').forEach(picker => { picker.classList.toggle('selected', picker.dataset.color.toLowerCase() === settings[settingKey].toLowerCase()); }); }
                     if (customInput) { customInput.value = settings[settingKey]; }
                 }
                 updateColorUI('textColorOptions', 'customTextColor', 'textColor'); updateColorUI('bgColorOptions', 'customBgColor', 'backgroundColor'); updateColorUI('otherTextColorOptions', 'customOtherTextColor', 'otherTextColor');

                const priceFontSizeSlider = document.getElementById('priceFontSize'); const priceFontSizeValue = document.getElementById('priceFontSizeValue'); if (priceFontSizeSlider) priceFontSizeSlider.value = settings.priceFontSize; if (priceFontSizeValue) priceFontSizeValue.textContent = settings.priceFontSize + '%';
                const otherFontSizeSlider = document.getElementById('otherFontSize'); const otherFontSizeValue = document.getElementById('otherFontSizeValue'); if (otherFontSizeSlider) otherFontSizeSlider.value = settings.otherFontSize; if (otherFontSizeValue) otherFontSizeValue.textContent = settings.otherFontSize + '%';

                // --- Update Font Selection State ---
                 const fontOptionsDiv = document.getElementById('fontOptions');
                 if(fontOptionsDiv){
                     fontOptionsDiv.querySelectorAll('.font-preview').forEach(preview => {
                         preview.classList.toggle('selected', preview.dataset.family === settings.fontFamily);
                     });
                 }

                // REMOVED showInstructionsCheckbox
                const showUpdateTimeCheckbox = document.getElementById('showUpdateTime');
                // REMOVED showUpdateFreqCheckbox
                const showApiNameCheckbox = document.getElementById('showApiName');
                const showBtcLabelCheckbox = document.getElementById('showBtcLabel');

                if(showUpdateTimeCheckbox) showUpdateTimeCheckbox.checked = settings.showUpdateTime;
                if(showApiNameCheckbox) showApiNameCheckbox.checked = settings.showApiName;
                if(showBtcLabelCheckbox) showBtcLabelCheckbox.checked = settings.showBtcLabel;

            } catch (e) { console.error('Error updating settings UI:', e); }
        }

        // --- Function to dynamically load a Google Font ---
        function loadGoogleFont(font, previewElement) {
            if (!font || !font.googleSegment || font.loaded) {
                 // console.log(`Font ${font?.name} doesn't need loading or is already loaded.`);
                 return Promise.resolve(); // Already loaded or not a Google Font
            }

            const fontUrl = `https://fonts.googleapis.com/css2?family=${font.googleSegment}&display=swap`;

             if (loadedFontLinks.has(fontUrl)) {
                 // console.log(`Link for ${font.name} already added.`);
                 font.loaded = true;
                 return Promise.resolve();
             }

            console.log(`Loading font: ${font.name}`);
            const indicator = document.createElement('div');
            indicator.className = 'loading-indicator';
            indicator.textContent = '...';
            if (previewElement) previewElement.appendChild(indicator);


            return new Promise((resolve, reject) => {
                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = fontUrl;
                link.id = `google-font-${font.googleSegment.split(':')[0]}`;

                link.onload = () => {
                    console.log(`CSS loaded for ${font.name}. Checking font readiness...`);
                    loadedFontLinks.add(fontUrl);
                    font.loaded = true;

                     document.fonts.load(`1em "${font.family.split(',')[0].replace(/['"]/g, '')}"`)
                        .then(() => {
                             console.log(`Font ${font.name} is ready to use.`);
                             if (previewElement && indicator.parentNode === previewElement) {
                                 previewElement.removeChild(indicator);
                             }
                             resolve();
                        })
                        .catch(err => {
                             console.error(`Failed to load font "${font.name}" via Font Loading API:`, err);
                             if (previewElement && indicator.parentNode === previewElement) {
                                 previewElement.removeChild(indicator);
                             }
                             reject(err);
                        });
                };

                link.onerror = (err) => {
                    console.error(`Failed to load Google Font CSS: ${fontUrl}`, err);
                    if (previewElement && indicator.parentNode === previewElement) {
                        previewElement.removeChild(indicator);
                    }
                    reject(new Error(`Failed to load CSS for ${font.name}`));
                };

                document.head.appendChild(link);
            });
        }


        function setupSettingsUI() {
            console.log("Setting up Settings UI...");
            const settingsButton = document.getElementById('settingsButton'); const settingsModal = document.getElementById('settingsModal');
            if (!settingsButton || !settingsModal) { console.error("Settings button or modal missing."); return; }

            settingsButton.addEventListener('click', (e) => { e.stopPropagation(); settingsModal.classList.toggle('visible'); if (settingsModal.classList.contains('visible')) { updateSettingsUI(); } });
            document.addEventListener('click', (e) => { if (settingsModal.classList.contains('visible') && e.target !== settingsButton && !settingsModal.contains(e.target) && e.target !== document.getElementById('fullscreenButton')) { settingsModal.classList.remove('visible'); } }, false); // Prevent closing if clicking fullscreen btn

            function setupColorOption(optionsId, customBtnId, customInputId, settingKey) {
                 const container = document.getElementById(optionsId); const customBtn = document.getElementById(customBtnId); const customInput = document.getElementById(customInputId); if (!container || !customBtn || !customInput) { console.error(`Missing elements for color: ${optionsId}`); return; }
                 container.querySelectorAll('.color-picker').forEach(picker => { picker.addEventListener('click', function(e) { e.stopPropagation(); settings[settingKey] = this.dataset.color; saveSetting(settingKey, settings[settingKey]); applySettings(); }); });
                 customBtn.addEventListener('click', (e) => { e.stopPropagation(); customInput.click(); });
                 customInput.addEventListener('input', function(e) { e.stopPropagation(); settings[settingKey] = this.value; applySettings(); }); // Apply live preview
                 customInput.addEventListener('change', function(e) { e.stopPropagation(); settings[settingKey] = this.value; saveSetting(settingKey, settings[settingKey]); applySettings(); }); // Save on final change
            }
            setupColorOption('textColorOptions', 'customTextColorBtn', 'customTextColor', 'textColor'); setupColorOption('bgColorOptions', 'customBgColorBtn', 'customBgColor', 'backgroundColor'); setupColorOption('otherTextColorOptions', 'customOtherTextColorBtn', 'customOtherTextColor', 'otherTextColor');

             function setupSlider(sliderId, valueDisplayId, settingKey) {
                 const slider = document.getElementById(sliderId); const valueDisplay = document.getElementById(valueDisplayId); if (!slider || !valueDisplay) { console.error(`Missing slider elements: ${sliderId}`); return; }
                 slider.addEventListener('input', function(e) { e.stopPropagation(); const value = parseInt(this.value); settings[settingKey] = value; valueDisplay.textContent = value + '%'; applySettings(); });
                 slider.addEventListener('change', function(e) { e.stopPropagation(); saveSetting(settingKey, settings[settingKey]); });
             }
             setupSlider('priceFontSize', 'priceFontSizeValue', 'priceFontSize'); setupSlider('otherFontSize', 'otherFontSizeValue', 'otherFontSize');

            // --- Generate and Setup Font Selection ---
            const fontOptionsDiv = document.getElementById('fontOptions');
            if (fontOptionsDiv) {
                fontOptionsDiv.innerHTML = ''; // Clear any static placeholders
                availableFonts.forEach((font, index) => {
                    const preview = document.createElement('div');
                    preview.className = 'font-preview';
                    preview.dataset.family = font.family;
                    preview.dataset.name = font.name;
                    preview.title = font.name;
                    preview.textContent = font.name;
                    preview.style.fontFamily = font.family;

                    if (index === 0) { preview.classList.add('arial-font'); }

                    preview.addEventListener('click', async function(e) {
                        e.stopPropagation();
                        const selectedFontFamily = this.dataset.family;
                        const selectedFontName = this.dataset.name;
                        const fontData = availableFonts.find(f => f.family === selectedFontFamily);

                        if (!fontData) return;

                        const currentlySelected = document.querySelector('.font-preview.selected');
                        if(currentlySelected === this) return;

                        if (fontData.googleSegment && !fontData.loaded) {
                             try {
                                 await loadGoogleFont(fontData, this);
                                 settings.fontFamily = selectedFontFamily;
                                 saveSetting('fontFamily', settings.fontFamily);
                                 applySettings();
                             } catch (error) {
                                 console.error(`Could not apply font ${selectedFontName}:`, error);
                                 window.showStatus(`Failed to load font: ${selectedFontName}`, 4000);
                             }
                        } else {
                            settings.fontFamily = selectedFontFamily;
                            saveSetting('fontFamily', settings.fontFamily);
                            applySettings();
                        }
                    });
                    fontOptionsDiv.appendChild(preview);
                });
            } else { console.error("Font options container not found."); }

            function setupToggle(checkboxId, settingKey) {
                const checkbox = document.getElementById(checkboxId); if (!checkbox) { console.warn(`Checkbox not found: ${checkboxId}`); return; }
                const label = checkbox.nextElementSibling; // Assuming label follows checkbox
                 const clickableArea = checkbox.closest('.toggle-option') || checkbox; // Prefer the container for click area

                 // Prevent double-triggering if label has 'for' attribute
                 if (label && label.tagName === 'LABEL' && label.htmlFor === checkboxId) {
                    // Let the default label click handle the checkbox toggle
                     checkbox.addEventListener('change', function(e) { settings[settingKey] = this.checked; saveSetting(settingKey, settings[settingKey]); applySettings(); });
                 } else {
                    // If no label or label doesn't use 'for', handle click on container/checkbox
                    clickableArea.addEventListener('click', function(e) {
                        if (e.target !== checkbox) { // If click wasn't directly on checkbox
                            e.stopPropagation();
                            checkbox.checked = !checkbox.checked; // Manually toggle
                            checkbox.dispatchEvent(new Event('change')); // Trigger change event
                        }
                    }, false); // Use bubbling phase
                    checkbox.addEventListener('change', function(e) { settings[settingKey] = this.checked; saveSetting(settingKey, settings[settingKey]); applySettings(); });
                }
            }
            // REMOVED setupToggle for showInstructions
            setupToggle('showUpdateTime', 'showUpdateTime');
            // REMOVED setupToggle for showUpdateFreq
            setupToggle('showApiName', 'showApiName');
            setupToggle('showBtcLabel', 'showBtcLabel');

             console.log("Settings UI setup complete.");
        }

        // Initialize settings after core is ready
        document.addEventListener('coreDisplayReady', initializeSettings);
        if (window.coreInitialized) { // Backup if this script runs late
             console.log("Core was ready, initializing settings immediately.");
             initializeSettings();
         }

    })(); // End of settings IIFE
    </script>
</body>
</html>
